'use strict';

var Fs = require('fs');
var Path = require('path');
var Util = require('../util.js');
exports = module.exports = function(args){
	return exports;
}

exports.processorName = "super";
exports.process = function(node, tplPath, parser, variables){
	
	
	var children = node.children;
	var replacer = {};
	for(var i = 0; i < children.length ; i++){
		var child = children[i];
		Util.traverseNodeTree(child, tplPath, function(node, superPath){
			if("override" == node.processorName){
				replacer[node.attribute.id] = node;
			}else if("super" == node.processorName){
				node.attribute.parent = Path.resolve(Path.dirname(tplPath), node.attribute.parent);
			}

		});
	}
	//console.log(replacer);
	var superPath = Path.resolve(Path.dirname(tplPath), node.attribute.parent);
	console.log(superPath);
	var superContext = Fs.readFileSync(superPath, parser.encoding);
	var superNode = parser.parse2node(superContext, superPath);
	
	Util.traverseNodeTree(superNode, superPath, function(node, superPath){
		if("super" == node.processorName){
			var relativePath = node.attribute.parent;
			node.attribute.parent = Path.resolve(Path.dirname(superPath), relativePath);
		}else if(node.processorName == "replacable"){
			console.log(node);
			if(undefined != replacer[node.attribute.id]){
				node.processorName = "";
				node.children = replacer[node.attribute.id].children;			
			}else{
				node.processorName = "";				
			}			
		}
	});
	//console.log(superNode.children);
	node.parentNode.children[node.parentIdx].children = superNode.children;
	node.parentNode.children[node.parentIdx].processorName = "";
}


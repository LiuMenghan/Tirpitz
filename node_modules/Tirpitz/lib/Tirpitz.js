'use strict';

var Fs = require('fs');
var Path = require('path');
var Parser = require('./parser.js');
var consoleHandler = require('./handler/ConsoleHandler.js');

exports = module.exports = function (args){
	//初始化
	for( var p in args){
		exports[p] = args[p];
	}
	
	//获取根目录
	var ancestor = module;
	var parent = ancestor.parent;
	while(parent != undefined && parent != null && parent != ''){
		ancestor = parent;
		parent = ancestor.parent;
	}
	
	rootDir = Path.dirname(ancestor.filename);
	
	//init processors
	//加载processor，先加载默认的
	if(defaultProcessorsDir != exports.processorsDir){
		console.log('defaultProcessorsDir=' + defaultProcessorsDir + '; this.processorsDir=' + exports.processorsDir);
		addProcessors('./' + defaultProcessorsDir);
	}

	//再加载自定义的，会扫描本js所有父目录下是否有和processorsDir名称相同的目录。如果有，加载该目录下所有的js
	resolveFileName(exports.processorsDir).forEach(function(dir){
		addProcessors(dir);
	});

	//init beforeInterceptors
	//加载前置拦截器
	exports.beforeInterceptorsFileNames.forEach(function(filename){
		resolveFileName(filename).forEach(function(interceptorPath){
			var interceptor = require(interceptorPath);
			console.log("beforeInterceptor[%s]:%s", interceptor.interceptorName, interceptorPath);
			exports.parser.beforeInterceptors.push(interceptor);
		});
	});

	//init afterInterceptors
	//加载后置拦截器
	exports.afterInterceptorsFileNames.forEach(function(filename){
		resolveFileName(filename).forEach(function(interceptorPath){
			var interceptor = require(interceptorPath);
			console.log("afterInterceptor[%s]:%s", interceptor.interceptorName, interceptorPath);
			exports.parser.afterInterceptors.push(interceptor);
		});
	});	
	
	//初始化解析器
	Parser.init(exports.parser);
	exports.parser = Parser;
	return exports;
}
exports.parser = {
	beforeInterceptors : [],	//前置拦截器
	afterInterceptors : [],	//后置拦截器
	elementProcessors : {},	//processor
	encoding : "utf-8",	//编码
	handler : consoleHandler	//输出
};
exports.tplPath = null;
exports.processorsDir = 'processor';
exports.beforeInterceptorsFileNames = [];
exports.afterInterceptorsFileNames = [];
exports.extendProcessorsDir = null;
exports.buildPath = null;

//渲染模版
exports.render = function(tplFileName, buildObj, variables){
	var _tplPath = Path.resolve(rootDir, exports.tplPath, tplFileName);
	var out = Parser.handler.getOutput(buildObj, rootDir, exports.buildPath);
	Parser.parse(_tplPath, out, variables);	
};

exports.findImplementions = function(absoluteDir){
	var result = [];
	
	var files = Fs.readdirSync(absoluteDir);
	files.forEach(function(file){
		var pathname = absoluteDir +'/'+file

		if (Fs.statSync(pathname).isDirectory()){
			var subFiles = Fs.readdirSync(pathname);
			subFiles.forEach(function(subFile){
				files.push(file + '/' + subFile);
			});
		}else{				
			var impl = require(pathname);
			impl.pathname = pathname;
			result.push(impl); 
		}
	});
	
	return result;
}

var rootDir = null;
var defaultProcessorsDir = 'processor';

var addProcessors = function(dir){
	var processors = exports.findImplementions(dir);
	processors.forEach(function(processor){
		console.log("processor[%s]:%s", processor.processorName, processor.pathname);
		exports.parser.elementProcessors[processor.processorName] = processor;
	});
}

var resolveFileName = function(relativeFileName){
	var result = [];
	if(relativeFileName == undefined || relativeFileName == null){
		return result;	
	}

	var dirnames = module.filename.split(Path.sep);
	for(var max = dirnames.length; max > 0; max --){
		var tmpPath = '/';
		for(var i = 0; i < max; i++){
			tmpPath = Path.resolve(tmpPath, dirnames[i]);
		}
		var tempPath = Path.resolve(tmpPath, relativeFileName);
		if(Fs.existsSync(tempPath)){
			result.push(tempPath);
		}
	}
	return result;
}

'use strict';
var Fs = require('fs');
var Path = require('path');
var Util = require('./util.js');
var TemplateNode = require('./TemplateNode.js')

exports = module.exports = function (args){
	for(var p in args){
		exports[p] = args[p];
	}
	
	exports.beforeInterceptors.push(parserInterceptor);
	
	rootDir = Path.dirname(ancestor.filename);
	
	return exports;
}

exports.beforeInterceptors = [];
exports.afterInterceptors = [];
exports.elementProcessors = {};
exports.starterTag = ["{%", "%}"];
exports.endTag = ["{%/", "%}"];
exports.singleTag = ["{%", "/%}"];
exports.assignSymbol = "=";
exports.escapeCharacter = "\\";
exports.tmpDir = './tmp';

exports.encoding = "utf-8";
exports.enableConfigurationCheck=true;
exports.enableSymbolCheck=true;

exports.init = function (args){
	for( var p in args){
		exports[p] = args[p];
	}
		
	if(exports.enableConfigurationCheck){
		checkTags({
			starterTag : exports.starterTag,
			endTag : exports.endTag,
			singleTag : exports.singleTag
		});
	}
	
	if(exports.enableSymbolCheck){
		checkSymbol({
			starterTag : exports.starterTag,
			endTag : exports.endTag,
			singleTag : exports.singleTag
		},{
			valueSymbol : exports.valueSymbol,
			assignSymbol : exports.assignSymbol,
			escapeCharacter : [exports.escapeCharacter]
		});
	}
}

exports.handler = null;

exports.parse = function(tplPath, out, variables){
	var starttime = new Date().getTime();
	
	var context = Fs.readFileSync(tplPath, exports.encoding);
	for(var i = 0; i < exports.beforeInterceptors.length; i++){
		var interceptor = exports.beforeInterceptors[i];
		
		context=interceptor.before(context);
	}
	//console.log("===Begin to parse to node.===");
	var rootNode = exports.parse2node(context);
	//console.log("===End parsing to node.===");
	
	//console.log("===Begin to do with processors.===");
	Util.traverseNodeTree(rootNode, exports.elementProcessors, function(node, processors){
		var processorName = node.processorName;
		
		if( "" == processorName ){
			return;
		}
		
		var processor = processors[processorName];
		if(undefined == processor){
			console.warn("No processor named %s found.", processorName);
		}else{
			processor.process(node, tplPath, exports);
		}
	});	
	//console.log("===End doing with processors.===");
	
	for(var i = 0; i < exports.afterInterceptors.length; i++){
		exports.afterInterceptors[i].after(rootNode);
	}	
	
	//console.log("===Begin to output.===");
	exports.handler.handle(rootNode, tplPath, out, starttime);
	//console.log("===End outputing.===");
	
}

var starterTag = exports.starterTag;
var endTag = exports.endTag;
var singleTag = exports.singleTag;

var parserStatus = {
	//constants
	readingText : 0,
	readingProcessorName : 1,
	readingAttributes : 2,
	endingStartElement : 3,
	endingSingleElement : 4,
	readingEndProcessorName : 5,
	endingEndElement : 6
}

exports.parse2node = function(context, tplPath){
	var rootNode = TemplateNode.build(null, [], "");
	var currentNode = rootNode;
	
	var text = "";
	var itr = {			
		//variables
		status : parserStatus.readingText,
		test : "",
		currentNode : rootNode,
		idx : 0,
		row : 0,
		line : "",
		column : 0,
		context : context,
		next : function(){
			var c = context[this.idx];
			//console.log("[%d,%d]%s", this.row, this.column, c);
			if('\n' == c){
				this.row ++;
				this.line = "";
				this.column = 0;
			}else{
				this.column ++;
				this.line += c;
			}
			this.idx ++;
			return c;
		},
		hasNext : function(){
			return this.idx < this.context.length;
		},
		
		tryReadingElement : function(c, status){
			this.tmp.tag += c;
			this.tmp.tagIdx++;
			this.tmp.beforeStatus.push(this.status);
			this.status = status;
		},
		
		confirmElement : function(status){
			this.tmp.tag = "";
			this.tmp.tagIdx = 0;
			this.tmp.beforeStatus.push(this.status);
			this.status = status;
			
		},
		
		denyElement : function(c){
			var result = this.tmp.tag += c;
			this.tmp.tag = "";
			this.tmp.tagIdx = 0;
			this.status = this.tmp.beforeStatus.pop();
			return result;
		},
		tmp : {
			tag : "",
			tagIdx : 0,
			processorName : "",	
			attributePlain : "",
			beforeStatus : [],
		}
	};
	
	while(itr.hasNext()){
			
		var c = itr.next();
		
		switch(itr.status){				
			case parserStatus.readingProcessorName:
				if(isBlank(c)){
					continue;
				}else if( c == exports.assignSymbol){
					itr.status = parserStatus.readingAttributes;
					
				}else if( c == exports.starterTag[1][0]){
					itr.tryReadingElement(c, parserStatus.endingStartElement);
					
				}else if( c == exports.singleTag[1][0]){
					itr.tryReadingElement(c, parserStatus.endingSingleElement);
					
				}else{
					itr.tmp.processorName += c;
				}
				break;
				
			case parserStatus.readingAttributes:
				if(c == exports.escapeCharacter){
					c = itr.next;
				}else if( c == exports.starterTag[1][0]){
					itr.tryReadingElement(c, parserStatus.endingStartElement);
					break;
					
				}else if( c == exports.singleTag[1][0]){
					itr.tryReadingElement(c, parserStatus.endingSingleElement);
					break;
					
				}
				
				itr.tmp.attributePlain += c;
				break;
				
			case parserStatus.endingStartElement:				
				if(c == starterTag[1][itr.tmp.tagIdx]){
					itr.tmp.tag += c;
					itr.tmp.tagIdx ++;
					
					if(itr.tmp.tag == starterTag[1]){
						//Confirm it is a tag.					
						//console.log(itr.tmp.attributePlain);
						var node = TemplateNode.build(itr.currentNode, [], text, itr.tmp.processorName, itr.tmp.attributePlain);
						text = "";
						itr.currentNode = node;
						itr.tmp.processorName = "";
						itr.tmp.attributePlain = "";
						itr.confirmElement(parserStatus.readingText);
						itr.tmp.beforeStatus = [];
					}
					
				}else{
					//It is not a start end tag.
					var tmp = itr.denyElement(c);
					if(parserStatus.readingProcessorName == itr.status){
						itr.tmp.attributePlain += tmp;
					}else{
						itr.tmp.processorName += tmp;
					}
				}
				break;
				
			case parserStatus.endingSingleElement:
				if(c == singleTag[1][itr.tmp.tagIdx]){
					itr.tmp.tag += c;
					itr.tmp.tagIdx ++;
					
					if(itr.tmp.tag == singleTag[1]){
						//Confirm it is a tag.
						var node = TemplateNode.build(itr.currentNode, [], text, itr.tmp.processorName, itr.tmp.attributePlain);
						text = "";
						itr.tmp.processorName = "";
						itr.tmp.attributePlain = "";
						itr.confirmElement(parserStatus.readingText);
						itr.tmp.beforeStatus = [];
					}
					
				}else{
					//It is not a start end tag.
					var tmp = itr.denyElement(c);
					if(parserStatus.readingProcessorName == itr.status){
						itr.tmp.processorName += tmp;
					}else{
						itr.tmp.attributePlain += tmp;
					}
				}
				break;
			
			case parserStatus.readingEndProcessorName:
				if(isBlank(c)){
					continue;
				}else if( c == exports.endTag[1][0]){
					itr.tryReadingElement(c, parserStatus.endingEndElement);
					
				}else{
					itr.tmp.processorName += c;
				}
				break;
				
			case parserStatus.endingEndElement:
			
				if(c == endTag[1][itr.tmp.tagIdx]){
					itr.tmp.tag += c;
					itr.tmp.tagIdx ++;
					
					if(itr.tmp.tag == endTag[1]){
						//Confirm it is a end tag.
						while(itr.currentNode.processorName != itr.tmp.processorName){
							itr.currentNode = itr.currentNode.parentNode;
							if(null == itr.currentNode){
								throw new Error("No start tag found for tag[%s]", itr.tmp.processorName);
							}
						}
						itr.currentNode = itr.currentNode.parentNode;
						itr.tmp.processorName = "";
						itr.tmp.attributePlain = "";
						itr.confirmElement(parserStatus.readingText);
						itr.tmp.beforeStatus = [];
					}
					
				}else{
					//It is not a end end tag.
					var tmp = itr.deny(c);
					itr.tmp.processorName += tmp;
				}
				break;
			
			case parserStatus.readingText :
			default:
				if(c == exports.escapeCharacter){
					c = itr.next();
					
				}else if( c == endTag[0][0] && endTag[0].length > starterTag[0].length && matchTag(endTag[0], itr)){					
					//It is end tag
					//console.log("Start %s with %s", endTag[0], c);
					var textNode = TemplateNode.build(itr.currentNode, [], text);
					text="";
					itr.confirmElement(parserStatus.readingEndProcessorName);
					break;					
				}else if( c == starterTag[0][0] && matchTag(starterTag[0], itr)){
					//It is starter tag	
					//console.log("Start %s with %s", starterTag[0], c);							
					var textNode = TemplateNode.build(itr.currentNode, [], text);
					text="";
					itr.confirmElement(parserStatus.readingProcessorName);
					break;
					
				}else if( c == endTag[0][0] && matchTag(endTag[0], itr)){					
					//It is end tag
					//console.log("Start %s with %s", endTag[0], c);
					var textNode = TemplateNode.build(itr.currentNode, [], text);
					text="";
					itr.confirmElement(parserStatus.readingEndProcessorName);
					break;					
				}
				text += c;			
		}
	}
	
	if(parserStatus.readingText != itr.status){
		//console.log(itr.tmp.processorName);
		throw new Error("Tag does not end correctly. \n" + itr.tmp);
	}
	var textNode = TemplateNode.build(currentNode, [], text);
	
	/*
	Util.traverseNodeTree(rootNode, null, function(node, out){
		node.parentNode = null;
	});
	console.log(JSON.stringify(rootNode));
	*/
	return rootNode;
	
}

var matchTag = function(tag, itr){
	var tmp = itr.context.substring(itr.idx - 1, itr.idx + tag.length - 1);
	if(tag == tmp){
		for(var i = 1; i < tag.length; i++){
			itr.next();
		}
		return true;
	}
	
	return false;
}

var isBlank = function(c){
	return c == " " || c == "\t" || c == "\n" || c == "\r";
}

var checkTags = function(tag){
	var taglist = [];
	for( var p in tag){
		if(tag[p].length < 2){
			throw new Error("Parser." + p + " must have two tags.");			
		}else if(null == tag[p][0] || "" == tag[p][0] || undefined == tag[p][0]){
			throw new Error("Paser." + p + "(left) cannot be null, empty or undefined.");
		}else if(null == tag[p][1] || "" == tag[p][1] || undefined == tag[p][1]){
			throw new Error("Paser." + p + "(left) cannot be null, empty or undefined.");
		}
	}
	
	for( var p0 in tag){
		for( var p1 in tag){
			if(p0 == p1){
				continue;
			}
			if(assertEquals(tag[p0], tag[p1])){
				throw new Error("Parser." + p0 + " and Parser." + p1 + " is the same.");
			} 			
		}
	}
	
	if(tag.starterTag[0] != tag.singleTag[0]){
		throw new Error("Parser.starterTag.left(" + tag.starterTag[0] + ") and Parser.singleTag.left(" + singleTag[0] + ") is different.");		
	}
}

var checkSymbol = function(used, toBeChecked){
	for( var pc in toBeChecked){
		for(var i in toBeChecked[pc]){
			var sc = toBeChecked[pc][i];
			for(var pu in used){
				for(var j in used[pu]){
					var su = used[pu][j];
					if(sc == su){
						throw new Error(pc + "[" + sc + "] has been used by " + pu + ".")
					}
				}
			}
					
			if(undefined == used[pc]){
				used[pc] = [];
			}
			
			used[pc].push(sc);
		}
	}
}

var assertEquals = function(tag1, tag2){
	return tag1[0] == tag2[0] && tag1[1] == tag2[1];
}

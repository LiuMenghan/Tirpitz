'use strict';
var Fs = require('fs');
var Path = require('path');
var Util = require('./util.js');
var TemplateNode = require('./TemplateNode.js')

exports = module.exports = function (args){
	for(var p in args){
		exports[p] = args[p];
	}
	
	//exports.beforeInterceptors.push(parserInterceptor);
	
	//rootDir = Path.dirname(ancestor.filename);
	
	return exports;
}

exports.beforeInterceptors = [];
exports.afterInterceptors = [];
exports.elementProcessors = {};
//模版语法类似xml
exports.starterTag = ["[[", "]]"];	//开始标签
exports.endTag = ["[[/", "]]"];	//结束标签
exports.singleTag = ["[[", "/]]"];	//独立标签
exports.assignSymbol = "=";	//赋值符号
exports.escapeCharacter = "\\";	//转义符号
exports.tmpDir = './tmp';	//临时文件夹

exports.encoding = "utf-8";	//编码格式
exports.enableConfigurationCheck=true;	//设置检查
exports.enableSymbolCheck=true;	//标签定义合法性检查

exports.init = function (args){
	for( var p in args){
		exports[p] = args[p];
	}
		
	//检查标签
	if(exports.enableConfigurationCheck){
		checkTags({
			starterTag : exports.starterTag,
			endTag : exports.endTag,
			singleTag : exports.singleTag
		});
	}
	
	//检查转义符号
	if(exports.enableSymbolCheck){
		checkSymbol({
			starterTag : exports.starterTag,
			endTag : exports.endTag,
			singleTag : exports.singleTag
		},{
			//valueSymbol : exports.valueSymbol,
			assignSymbol : exports.assignSymbol,
			escapeCharacter : [exports.escapeCharacter]
		});
	}
}

exports.handler = null;

exports.parse = function(tplPath, out, variables){
	var starttime = new Date().getTime();
	console.log("Begin to parse %s", tplPath);
	
	//读取文件
	var context = Fs.readFileSync(tplPath, exports.encoding);
	
	//前置拦截
	for(var i = 0; i < exports.beforeInterceptors.length; i++){
		var interceptor = exports.beforeInterceptors[i];
		
		context=interceptor.before(context);
	}
	//console.log("===Begin to parse to node.===");
	//解析成模版树
	var rootNode = exports.parse2node(context);
	//console.log("===End parsing to node.===");
	
	//console.log("===Begin to do with processors.===");
	//深度遍历模版树，调用processor进行处理
	Util.traverseNodeTree(rootNode, exports.elementProcessors, function(node, processors){
		var processorName = node.processorName;
		
		if( "" == processorName ){
			return;
		}
		
		var processor = processors[processorName];
		if(undefined == processor){
			console.warn("No processor named %s found.", processorName);
		}else{
			processor.process(node, tplPath, exports, variables);
		}
	});	
	//console.log("===End doing with processors.===");
	
	//后置拦截
	for(var i = 0; i < exports.afterInterceptors.length; i++){
		exports.afterInterceptors[i].after(rootNode);
	}	
	
	//console.log("===Begin to output.===");
	//输出
	exports.handler.handle(rootNode, tplPath, out, starttime);
	//console.log("===End outputing.===");
	
}

var starterTag = exports.starterTag;
var endTag = exports.endTag;
var singleTag = exports.singleTag;

//解析器状态
var parserStatus = {
	//constants
	readingText : 0,	//读取文本
	readingProcessorName : 1,	//开始标签中读取processor名称
	readingAttributes : 2,	//读取属性
	endingStartElement : 3,	//在读取开始标签的结束标签
	endingSingleElement : 4,	//在读取独立标签的结束标签
	readingEndProcessorName : 5,	//结束标签中读取processor名称
	endingEndElement : 6	//在读取结束标签的结束标签
}

exports.parse2node = function(context, tplPath){
	var rootNode = TemplateNode.build(null, [], "");
	var currentNode = rootNode;
	
	var text = "";
	
	//迭代器
	var itr = {			
		//variables
		status : parserStatus.readingText,	//状态
		test : "",
		currentNode : rootNode,	//当前节点
		idx : 0,	//字符下标
		row : 0,	//行数
		line : "",	//行文本
		column : 0,	//列数
		context : context,	//所有文本
		
		//迭代
		next : function(){
			var c = context[this.idx];
			//console.log("[%d,%d]%s", this.row, this.column, c);
			if('\n' == c){
				this.row ++;
				this.line = "";
				this.column = 0;
			}else{
				this.column ++;
				this.line += c;
			}
			this.idx ++;
			return c;
		},
		
		//是否结束
		hasNext : function(){
			return this.idx < this.context.length;
		},
		
		//尝试开始读一个标签
		tryReadingElement : function(c, status){
			this.tmp.tag += c;
			this.tmp.tagIdx++;
			this.tmp.beforeStatus.push(this.status);
			this.status = status;
		},
		
		//确认读到的是一个标签
		confirmElement : function(status){
			this.tmp.tag = "";
			this.tmp.tagIdx = 0;
			this.tmp.beforeStatus.push(this.status);
			this.status = status;
			
		},
		
		//读的不是标签，回退
		denyElement : function(c){
			var result = this.tmp.tag += c;
			this.tmp.tag = "";
			this.tmp.tagIdx = 0;
			this.status = this.tmp.beforeStatus.pop();
			return result;
		},
		
		tmp : {
			tag : "",
			tagIdx : 0,
			processorName : "",	
			attributePlain : "",
			beforeStatus : [],
		}
	};
	
	while(itr.hasNext()){
			
		var c = itr.next();
		
		switch(itr.status){	
			case parserStatus.readingProcessorName:
				//正在读取processor名称
				if(isBlank(c)){
					//忽略空格
					continue;
				}else if( c == exports.assignSymbol){
					//如果是赋值符号的话变成赋值状态
					itr.status = parserStatus.readingAttributes;
					
				}else if( c == exports.starterTag[1][0]){
					//如果是开始的标签结束标签的第一个字符，可能准备结束
					itr.tryReadingElement(c, parserStatus.endingStartElement);
					
				}else if( c == exports.singleTag[1][0]){
					//如果是独立标签结束的第一个字符，可能准备结束
					itr.tryReadingElement(c, parserStatus.endingSingleElement);
					
				}else{
					itr.tmp.processorName += c;
				}
				break;
				
			case parserStatus.readingAttributes:
				//读取属性
				if(c == exports.escapeCharacter){
					c = itr.next;
				}else if( c == exports.starterTag[1][0]){
					//如果是开始的标签结束标签的第一个字符，可能准备结束
					itr.tryReadingElement(c, parserStatus.endingStartElement);
					break;
					
				}else if( c == exports.singleTag[1][0]){
					//如果是独立标签结束的第一个字符，可能准备结束
					itr.tryReadingElement(c, parserStatus.endingSingleElement);
					break;
					
				}
				
				itr.tmp.attributePlain += c;
				break;
				
			case parserStatus.endingStartElement:
				//尝试结束开始标签
				if(c == starterTag[1][itr.tmp.tagIdx]){
					itr.tmp.tag += c;
					itr.tmp.tagIdx ++;
					
					//如果读到的临时标签与开始标签的结束标签完全一致，那么开始标签结束，生成模版树节点，当前节点变为新生成节点
					if(itr.tmp.tag == starterTag[1]){
						//Confirm it is a tag.					
						//console.log(itr.tmp.attributePlain);
						var node = TemplateNode.build(itr.currentNode, [], text, itr.tmp.processorName, itr.tmp.attributePlain);
						text = "";
						itr.currentNode = node;
						itr.tmp.processorName = "";
						itr.tmp.attributePlain = "";
						itr.confirmElement(parserStatus.readingText);
						itr.tmp.beforeStatus = [];
					}
					
				}else{
					//It is not a start end tag.
					//开始标签未结束，回退
					var tmp = itr.denyElement(c);
					if(parserStatus.readingProcessorName == itr.status){
						itr.tmp.attributePlain += tmp;
					}else{
						itr.tmp.processorName += tmp;
					}
				}
				break;
				
			case parserStatus.endingSingleElement:
				//尝试结束独立标签
				if(c == singleTag[1][itr.tmp.tagIdx]){
					itr.tmp.tag += c;
					itr.tmp.tagIdx ++;
					
					
					//如果读到的临时标签与独立标签的结束标签完全一致，那么开始标签结束，生成模版树节点
					if(itr.tmp.tag == singleTag[1]){
						//Confirm it is a tag.
						var node = TemplateNode.build(itr.currentNode, [], text, itr.tmp.processorName, itr.tmp.attributePlain);
						text = "";
						itr.tmp.processorName = "";
						itr.tmp.attributePlain = "";
						itr.confirmElement(parserStatus.readingText);
						itr.tmp.beforeStatus = [];
					}
					
				}else{
					//It is not a start end tag.
					//开始标签未结束，回退
					var tmp = itr.denyElement(c);
					if(parserStatus.readingProcessorName == itr.status){
						itr.tmp.processorName += tmp;
					}else{
						itr.tmp.attributePlain += tmp;
					}
				}
				break;
			
			case parserStatus.readingEndProcessorName:
				//读取结束标签的processor名称
				if(isBlank(c)){
					continue;
				}else if( c == exports.endTag[1][0]){
					itr.tryReadingElement(c, parserStatus.endingEndElement);
					
				}else{
					itr.tmp.processorName += c;
				}
				break;
			
			case parserStatus.endingEndElement:
				//结束结束标签
				if(c == endTag[1][itr.tmp.tagIdx]){
					itr.tmp.tag += c;
					itr.tmp.tagIdx ++;
					
					if(itr.tmp.tag == endTag[1]){
						//结束标签结束，当前节点变为父节点
						//Confirm it is a end tag.
						while(itr.currentNode.processorName != itr.tmp.processorName){
							itr.currentNode = itr.currentNode.parentNode;
							if(null == itr.currentNode){
								throw new Error("No start tag found for tag[%s]", itr.tmp.processorName);
							}
						}
						itr.currentNode = itr.currentNode.parentNode;
						itr.tmp.processorName = "";
						itr.tmp.attributePlain = "";
						itr.confirmElement(parserStatus.readingText);
						itr.tmp.beforeStatus = [];
					}
					
				}else{
					//It is not a end end tag.
					//结束标签未结束，回退
					var tmp = itr.denyElement(c);
					itr.tmp.processorName += tmp;
				}
				break;
			
			case parserStatus.readingText :
			default:
				//读取文本
				if(c == exports.escapeCharacter){
					//如果是转义字符，直接读取下一个字符
					c = itr.next();
					
				}else if( c == endTag[0][0] && endTag[0].length > starterTag[0].length && matchTag(endTag[0], itr)){
					//读到结束标签
					//It is end tag
					//console.log("Start %s with %s", endTag[0], c);
					var textNode = TemplateNode.build(itr.currentNode, [], text);
					text="";
					itr.confirmElement(parserStatus.readingEndProcessorName);
					break;					
				}else if( c == starterTag[0][0] && matchTag(starterTag[0], itr)){
					//读到开始标签
					//It is starter tag	
					//console.log("Start %s with %s", starterTag[0], c);							
					var textNode = TemplateNode.build(itr.currentNode, [], text);
					text="";
					itr.confirmElement(parserStatus.readingProcessorName);
					break;
					
				}else if( c == endTag[0][0] && matchTag(endTag[0], itr)){	
					//读到结束标签				
					//It is end tag
					//console.log("Start %s with %s", endTag[0], c);
					var textNode = TemplateNode.build(itr.currentNode, [], text);
					text="";
					itr.confirmElement(parserStatus.readingEndProcessorName);
					break;					
				}
				text += c;			
		}
	}
	
	if(parserStatus.readingText != itr.status){
		//console.log(itr.tmp.processorName);
		//如果最后标签没有闭合
		throw new Error("Tag does not end correctly. \n" + itr.tmp);
	}
	var textNode = TemplateNode.build(currentNode, [], text);
	
	/*
	Util.traverseNodeTree(rootNode, null, function(node, out){
		node.parentNode = null;
	});
	console.log(JSON.stringify(rootNode));
	*/
	return rootNode;
	
}

var matchTag = function(tag, itr){
	var tmp = itr.context.substring(itr.idx - 1, itr.idx + tag.length - 1);
	if(tag == tmp){
		for(var i = 1; i < tag.length; i++){
			itr.next();
		}
		return true;
	}
	
	return false;
}

var isBlank = function(c){
	return c == " " || c == "\t" || c == "\n" || c == "\r";
}

//标签检查
var checkTags = function(tag){
	var taglist = [];
	for( var p in tag){
		if(tag[p].length < 2){
			//所有标签都必须成对出现
			throw new Error("Parser." + p + " must have two tags.");			
		}else if(null == tag[p][0] || "" == tag[p][0] || undefined == tag[p][0]){
			//所有标签不能为空或者undefined
			throw new Error("Paser." + p + "(left) cannot be null, empty or undefined.");
		}else if(null == tag[p][1] || "" == tag[p][1] || undefined == tag[p][1]){
			//所有标签不能为空或者undefined
			throw new Error("Paser." + p + "(left) cannot be null, empty or undefined.");
		}
	}
	
	for( var p0 in tag){
		for( var p1 in tag){
			if(p0 == p1){
				continue;
			}
			if(assertEquals(tag[p0], tag[p1])){
				//所有标签的不能完全一致
				throw new Error("Parser." + p0 + " and Parser." + p1 + " is the same.");
			} 			
		}
	}
	
	if(tag.starterTag[0] != tag.singleTag[0]){
		//目前要求开始标签和独立标签的第一个标签相同
		throw new Error("Parser.starterTag.left(" + tag.starterTag[0] + ") and Parser.singleTag.left(" + singleTag[0] + ") is different.");		
	}
}

//赋值、转义符号不能被使用过
var checkSymbol = function(used, toBeChecked){
	for( var pc in toBeChecked){
		for(var i in toBeChecked[pc]){
			var sc = toBeChecked[pc][i];
			for(var pu in used){
				for(var j in used[pu]){
					var su = used[pu][j];
					if(sc == su){
						throw new Error(pc + "[" + sc + "] has been used by " + pu + ".")
					}
				}
			}
					
			if(undefined == used[pc]){
				used[pc] = [];
			}
			
			used[pc].push(sc);
		}
	}
}

var assertEquals = function(tag1, tag2){
	return tag1[0] == tag2[0] && tag1[1] == tag2[1];
}

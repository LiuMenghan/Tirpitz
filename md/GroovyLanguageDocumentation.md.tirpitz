#Groovy Language Documentation:cn:

***

#<a name="translation" />写在前面的自娱自乐Q&A</a>
Q:为啥要翻译Groovy-doc啊?
A:前两天某新鲜出炉的编程语言流行排行榜上Groovy刚上升到15位，而处于前十名的都是Java、C、C++之类经久不衰的语言。同时我们看到，无论是gradle的流行，以及spring.io上越来越多的demo和test case都在使用Groovy编写，似乎都在验证Groovy是一门比Java开发效率更高的语言，Groovy可能会更加流行，也许在不久的Groovy就可以比肩他的前辈们了。
*我才不会说其实是因为我实在太闲。。。*
Q：翻译质量如何啊？
A：当然会尽自己所能保证翻译的准确性,可能有问题的地方我都会标注英文原文，当然有些用英文比用中文更好的地方我就直接用英文啦，，当然指望我老老实实的翻译是不现实的，所以估计会看到大量的吐槽、私货和表情:flushed::flushed::flushed:

***

#<a name="introduction" />简介</a>
Groovy...
- 是基于JVM一门敏捷、动态的语言
- 基于Java，具有Java的强大之处，但额外借鉴了其它语言（如Python、Ruby、Smalltalk）的强大特性
*直接运行在JVM之上、生成的文件同样是编译成为.class文件完全看不出任何区别，把Java迁移到Groovy只需要改个文件扩展名。。。所以放心大胆地用Java的语法写Groovy吧。。。至于“强大特性”？慢慢学呗，能用多少用多少呗，用上了就赚，用不上也没亏。。。*
- 使Java开发者可以以近乎于0的学习成本使用现代语言特性
*如果学习如何修改文件扩展名也算是学习成本的一部分的话。。。*
- 可以静态类型检查和静态编译，从而提升代码的健壮性、和性能
*作为运行时动态语言的坚决反对者，我的观点一向是编写的时候是动态语言，在编译之后成为静态语言，然后以静态语言的效率在生产环境运行。动态语言的开发效率会高很多，但是运行时和静态语言的运行效率相比一般要至少差出一个数量级以上，而仔细分析好像在实际上运行的时候鲜少真的需要所谓的动态特性（反射算静态），归根结底我们其实需要的是一门可以像动态语言一样开发的静态语言罢了。。。*
- 支持DSL和其它语法，从而让你的代码容易阅读和维护
*老实讲，我觉得Groovy写的DSL对于没有编程基础的人来说仍然不是易于阅读和维护的，但至少比java和xml配置文件什么的已经强上太多*
- 具有强大的处理原语(processing primitives)，面向对象能力和Ant DSL，使编写shell、构建脚本变得容易
*我觉得在这个Linux都自带python的世界里用Groovy写脚本可能并不是一个特别好的主意，毕竟有多少机器上安装了GDK呢？另外processing primitives怎么翻译？求指导*
- 通过减少开发web、GUI、数据库、控制台应用时的结构性代码，提高开发者的生产效率
*我觉得我eclipse用的最多的快捷键绝对是`Alt + shift + s`，getters&setters、toString、构造函数，想想都蛋疼。。。虽然IDE可以帮忙生成这些代码，但是谁说自动生成的代码就不需要维护的？维护成本永远高于开发成本，而这些代码完全可以在编译的时候由编译器自动生成吧。。。*
- 通过单元测试和开箱mock（mocking out-of-the-box)简化测试
*Groovy初始化对象比Java方便许多，所以在需要经常性初始化mock对象的测试中很方便；另外Groovy的assert要比Java好用很多，这也是为什么越来越多的单元测试都使用Groovy编写的原因吧*
- 无缝集成所有已有的Java类和lib
*编译完了和Java一样都是.class。Java可以无缝集成Java，这不废话吗。。。*
- 直接编译成Java字节码，所以你可以在任何可以使用Java的地方使用Groovy
*这句话可能并不是%100准确，比如Android的构建现在已经广泛使用gradle，但是好像没听说哪个APP是用Groovy写的*

***

#1.Groovy语言特性(Groovy Language Specification)

***

##1.1语法(Syntax)
本章包括Groovy程序语言的语法。Groovy的语法源于Java语法，但通过面向Groovy的特殊构建对Java语法进行了提升，同时允许一定的简化。

***

###1.1.1注释(Comments)
*除了Shebang行其它和Java毫无区别，我有预感“和Java毫无区别”这几个字会重复无数遍*

####单行注释(Single line comment)
单行注释以`//`开始并且可以放置在一行中的任何位置。`//`后直到行尾的所有字符都会被看作是注释的一部分。
```
// a standalone single line comment
println "hello" // a comment till the end of the line
```

####多行注释(Multiline Comment)
多行注释以`/*`开头并且可以放置在一行中的任意位置。`/*`后直到`*/`之间所有的字符(包括换行符)都会被认为是注释。多行注释因此可以被放置声明结束结束的地方，甚至是在声明之中。
```
/* a standalone multiline comment
   spanning two lines */
println "hello" /* a multiline comment starting
                   at the end of a statement */
println 1 /* one */ + 2 /* two */
```

####GroovyDoc注释(GroovyDoc comment)
*没看出和JavaDoc注释有半毛钱区别，然而改了个名字。。。*
和多行注释类似，GroovyDoc注释是多行的，但是以`/**`开始，以`*/`结束。在第一个GroovyDoc注释后面的行可以选择以`*`开始，这些注释会关联:
-类型定义(class,interface,enum,annotation)
-field和property定义
-method定义
尽管编译器编译以上内容时即使没有GroovyDoc注释也可以，您还是应该在上面这些定义之前加入您的GroovyDoc。
```
/**
 * A Class description
 */
class Person {
    /** the name of the person */
    String name

    /**
     * Creates a greeting method for a certain person.
     *
     * @param otherPerson the person to greet
     * @return a greeting message
     */
    String greet(String otherPerson) {
       "Hello ${otherPerson}"
    }
}
```
GroovyDoc遵顼与JavaDoc相同的约定，所以你可以像使用JavaDoc一样使用同样的标签。

####Shebang line
除了单行注释外，还有一种特殊的行注释叫shebang line。如果安装了Groovy运行环境且`Path`中有`groovy`命令，shebang line可以让groovy程序直接通过命令行执行
```
#!/usr/bin/env groovy
println "Hello from the shebang line"
```
__`#`必须是文件的首个字符，否则编译时会报错。__

***

###keyword
以下是所有Groovy语言的Keyword
- as
- assert
- break
- case
- catch
- class
- const
- continue
- def
- default
- do
- else
- enum
- extends
- false
- finally
- for
- goto
- if
- implements
- import
- in
- instanceof
- interface
- new
- null
- package
- return
- super
- switch
- this
- throw
- throws
- trait
- true
- try
- while
*这里面比Java多了as和trait两个关键字*

***

###identifier

####普通identifiers
identifier以字母、`$`或者下划线开始，不能以数字开始。
字母可以包括以下:
- 'a'到'z'(小写ascii字母)
- 'A'到'Z'(大写ascii字母)
- '\\u00C0'到'\\u00D6'
- '\\u00D8'到'\\u00F6'
- '\\u00F8'到'\\u00FF'
- '\\u0100'到'\\uFFFE'
非首字母可以包括字母和数字
下面是一些合法的identifier例子(此处以变量为例):
```
def name
def item3
def with_underscore
def $dollarStart
```
下面是不合法的identifier:
```
def 3tier
def a+b
def a#b
```
所有的keyword在`.`后面也是合法的identifier:
```
foo.as
foo.assert
foo.break
foo.case
foo.catch
```

####Quoted identifier

Quoted identifier在dotted expression的`.`之后出现。比如，`person.name`表达式中的`name`可以加引号写成`person."name"`或者`person.'name'`。有些字符被Java语言特性禁止，但是Groovy在使用引号时允许，这个时候quoted identifier尤其有用，如减号、空格、感叹号等。
```
def map = [:]

map."an identifier with a space and double quotes" = "ALLOWED"
map.'with-dash-signs-and-single-quotes' = "ALLOWED"

assert map."an identifier with a space and double quotes" == "ALLOWED"
assert map.'with-dash-signs-and-single-quotes' == "ALLOWED"
```
在<a href="#Strings">String</a>中Groovy提供了多种类型的String，所有类型的String都可以在`.`之后：
```
map.'single quote'
map."double quote"
map.'''triple single quote'''
map."""triple double quote"""
map./slashy string/
map.$/dollar slashy string/$
```
普通字符串和GString有一点不同，后者会将字符串表达式中的变量进行替换:
```
def firstname = "Homer"
map."Simson-${firstname}" = "Homer Simson"

assert map.'Simson-Homer' == "Homer Simson"
```

***

##1.1.4 字符串

以一串字母形式表示的文本文字被称作字符串。Groovy可以让你初始化`java.lang.String`对象，或者GString(`groovy.lang.GString`)(在其他语言中的被称作插值替换字串)

### 单引号字符串

但银行字符串是一系列被单引号包围的字符:
```
'a single quoted string'
```
__单引号字符串就是`java.lang.String`，不支持插值替换__
*于是Groovy里面好像就没有char这个类型，不过好像char在实际工作中的功能也就是String的子集？*

###字符串连接

所有的Groovy字符串都可以用+连接
```
assert 'ab' == 'a' + 'b'
```
*虽然Java里经常这么写，但是Groovy中可能用处并不大。字符串拼接个人认为通常有两种情况，与逻辑无关的固定格式的拼装和与逻辑相关的字符串拼装。前者使用GString明显更好，后者使用StringBuffer或者StringBuilder好一些。*

###三单引号字符串

三单引号字符串是一系列被三个单引号包围的字符:
```
'''a triple single quoted string'''
__三单引号字符串就是`java.lang.String`，不支持插值替换__
三单引号是多行的，你可以让你的内容跨越多行而不需要把字符串拆成多个片段，不需要连接符(contatenation)或者转义换行符。
*我猜contatenation可能是拼写错了，应该拼写成concatenation*
如果你的代码是缩进的，比如class中的方法体,你的字符串会包含缩进符的空白。Groovy Development Kit(GDK)含有去除缩进的方法——`String#stripIdent()`,使用该方法可以使用定界符来去除行开始之前的缩进。
当我们创建如下字符串:
```
def startingAndEndingWithANewline = '''
line one
line two
line three
'''
```
你会注意到结果字符串包含有一个换行字符作为首字符。可以使用反斜线跳过换行符:
```
def strippedFirstNewline = '''\\
line one
line two
line three
'''
```

####特殊转义字符

可以使用反斜线转义单引号避免结束字符串文字:
```
'an escaped single quote: \\' needs a backslash'
```
可以使用两个反斜线转义转义字符:
```
'an escaped escape character: \\\\ needs a double backslash'
```
一些特殊字符也使用反斜线作为转义字符
<table>
	<tr>
		<td>Escape sequence</td>
		<td>Character</td>
	</tr>
	<tr>
		<td>'\\t'</td>
		<td>制表符</td>
	</tr>
	<tr>
		<td>'\\b'</td>
		<td>退格</td>
	</tr>
	<tr>
		<td>'\\n'</td>
		<td>换行</td>
	</tr>
	<tr>
		<td>'\\r'</td>
		<td>回车</td>
	</tr>
	<tr>
		<td>'\\f'</td>
		<td>换页符</td>
	</tr>
	<tr>
		<td>'\\\\'</td>
		<td>反斜线</td>
	</tr
	<tr>
		<td>'\\''</td>
		<td>单引号(对于单引号和三单引号字符串)</td>
	</tr>
	<tr>
		<td>'\\"'</td>
		<td>双引号(对于双引号和三双引号字符串)</td>
	</tr>
</table>

####Unidcode转义字符

对于键盘上没有的字符，可以只用unicode转义字符:一个反斜线、'u'、4个人十六进制数字
比如欧元符号可以这样表示:
```
'The Euro currency symbol: \\u20AC'
```

###双引号字符串

双引号字符串是一系列由双引号包含的字符
```
"a double quoted string:
```
__如果没有插值表达式，双引号字符串是`java.lang.String`；如果有，是`groovy.lang.GString`。__

####字符串插值
任何Groovy表达式都可以被用在除单引号字符串和三单引号字符串外来作字符串插值。将字符串中的占位符替换成相应的值的行为叫做插值。占位符表达式用`${}`包围或以`$`为前缀。当把GString作为参数传递给一个方法时，占位符中的表达式会被通过调用`toString()`替换成相应的值。
*这段话的意思并不是说GString只有当传递给某方法时才会确定他的值，而是说当方法传递参数时会自动对GString进行替换。GString的值在GString出现的时候就已经应该确定并成为普通的String了。可以看译者下面写的例子：*
*^o^译者代码的分割线^o^*
```
def name = 'world';
def str = "Hello ${name}!";
name = 'Liu Menghan'
assert str == 'Hello world!';
assert  "Hello ${name}!" == 'Hello Liu Menghan!'
```
*^o^译者代码的分割线^o^*
除了`${}`占位符之外，我们也可以用单独的`$`符号作为一个dotted expression的前缀:
```
def person = [name: 'Guillaume', age:36]
assert "$person.name is $person.age years old" == 'Guillaume is 36 years old'
```
但是只有`a.b`，`a.b.v`等形式是有效的，包含括号的形式（方法调用、闭包调用、运算符）是无效的。给一个如下的数字定义:
```
def number = 3.14
```
下面的描述会抛出一个`groovy.lang.MissingPropertyException`，因为Groovy会认为你在试图获取一个数字的toString属性，但是这个属性并不存在。
```
shouldFail(MissingPropertyException){
	println "$number.toString()"
}
```
__你可以把`"$number.toString()"`理解成`"${number.toString}()"`__
*囧*
如果你需要转义GString中`$`或者`${}`占位符，从而让他们不以插值的形式出现，你只需要使用`\\\\`反斜线字符来转移美元符号:
```
assert '${name}' == "\${name}"
```
*请注意单双引号，请注意单双引号，请注意单双引号。重要的事情说三遍。*

####转义闭包(Closure)时的特殊情况

*闭包是Groovy和Java最大的差别之一，有<a href="#Closures">闭包</a>一章中会专门探讨。虽然闭包本身是一个值得大吹特吹的特性，但是我不觉得在字符串插值中使用闭包（尤其是复杂闭包）是一个好主意。在Java8推出lambda表达式之前Groovy可以全兼容Java语法，推出之后除了一点点问题——因为closure和lambda冲突了。实际上无论是closure还是lambda都是借鉴于其它语言，实现的目的都是函数式编程，但相对于closure而言，Java8为了不对虚拟机做大的修改，实际上只实现了closure很小的一部分功能，换句话说lambda所能实现的功能充其量也就是缩水了再缩水版的closure。但是lambda的意义并不仅仅是一种语法糖，因为lambda以及stream对异步编程来说非常友好，这可能会引发一直作为同步编程语言的Java个巨大的改变，这对closure可能同样会是一种促进。*
目前为止，我们已经可以用`${}`占位符中任意的表达式来进行插值，但是仍有一中特殊的情况就是闭包(Closure)表达式。当占位符中有一个箭头`${->}`，这种表达式实际上是一个闭包表达式——你可以认为它是一个有美元符号前缀的闭包:
```
def sParameterLessClosure = "1 + 2 == ${ -> 3 }" ////1.
assert sParameterLessClosure == '1 + 2 == 3'

def sOneParamClosure = "1 + 2 == ${ w -> w << 3}"////2.
assert sOneParamClosure == '1 + 2 == 3'
1.闭包是一个无参数闭包
2.闭包有一个单独的`java.io.StringWriter`参数，你可以通过`<<`左移操作符添加内容。两种占位符都嵌入了闭包
